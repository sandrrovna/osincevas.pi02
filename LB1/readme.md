МАССИВЫ:
	Python:
	В Python массивы реализованы через структуру данных списки. Списки являются частью 
	стандартных библиотек и обладают рядом удобных свойств:
		Они могут содержать разнотипные объекты (числа, строки, другие списки и т.п.).
		Размеры списков не фиксированы: они увеличиваются или уменьшаются динамически.
		Доступны стандартные методы для манипуляций с элементами (добавления, удаления, 
		сортировки и т.д.).
	Java:
	В Java работа с массивами строится иначе. Здесь массивы требуют чёткого задания типа 
	данных и количества элементов ещё на этапе инициализации:
		После создания длина массива становится постоянной и не изменяется.
		Тип всех элементов массива обязательно должен совпадать (целочисленные, 
		строковые и т.д.)
	C++:
	В C++ массивы имеют две формы реализации:
		Статические массивы: задаются заранее, ограничены размером и типом данных, 
		которые нельзя поменять позже.
		Динамические массивы: выделяются оператором new, и память освобождается 
		оператором delete, но расширение массива придётся производить вручную.
Главные отличия организации массивов:
	Типизация и однородность данных:
		Python: список может хранить разные типы данных одновременно.
		Java: все элементы массива должны быть одного типа.
		C++: аналогично Java, кроме случаев использования специальных шаблонов 
		(STL-контейнеры).
	Размер массива:
		Python: поддерживает автоматическое увеличение размера.
		Java: обычный массив имеет фиксированный размер, но можно воспользоваться 
		динамическим контейнером (ArrayList).
		C++: статические массивы фиксированные, динамические требуют ручного управления, 
		но STL-контейнер vector удобен для расширения.
	Управление памятью:
		Python: не требует ручной работы с памятью.
		Java: примитивные массивы не нуждаются в управлении памятью, но контейнеры сами 
		управляют ресурсами.
		C++: динамическое выделение памяти (через оператор new) и освобождение (через 
		delete) остаётся ответственностью разработчика.

СТЕКИ:
	Python:
	В Python стек реализуется с помощью стандартного списка или модуля collections.deque. 
	Стандартный метод добавления элементов — append() (или .push() в терминологии стеков), 
	а извлечение осуществляется методом pop(). Благодаря внутренней оптимизации, эти операции 
	выполняются эффективно даже для больших объемов данных.
	Java:
	В Java существуют два основных варианта реализации стека:
		Класс Stack: унаследован от вектора и обеспечивает классический интерфейс для 
		работы со стеком (методы push(), pop(), peek() и т.д.). Однако он менее 
		эффективен и редко рекомендуется к применению в современных проектах.
		Класс Deque (например, через объект LinkedList): реализует очередь с двусторонним 
		концом, но также подходит для эффективного создания стека, поскольку обладает 
		всеми необходимыми методами (addFirst(), removeFirst() и др.) и демонстрирует 
		лучшую производительность.
	C++:
	В C++ стандартный способ работы со стеком — использование шаблона std::stack из 
	библиотеки <stack>. Этот шаблон основан на другом контейнере (обычно deque или vector), 
	обеспечивая функциональность стека (операции push(), pop(), top() и проверку наличия 
	элементов empty()). Хотя std::stack абстрактен и скрывает базовую реализацию, разработчики 
	могут выбирать наиболее подходящий внутренний контейнер для конкретных 
	производительности.
Главные отличия организации стеков:
Python: простота реализации с помощью встроенного списка, что делает работу со стеком удобной и 
быстрой.
Java: выбор между устаревшим классом Stack и современным интерфейсом очереди Deque, который 
предпочтительнее для новых проектов.
C++: абстрагирование стека через шаблон, позволяющий гибко выбрать внутренний контейнер, 
оптимизированный под требования программы (производительность, потребление памяти и т.д.).
