#Блочная (корзинная) сортировка
def bucket_sort(arr):
    # Если массив пуст или состоит всего из одного элемента,
    # возвращаем его сразу, так как он уже отсортирован
    if len(arr) <= 1:
        return arr

    # Определяем минимальное и максимальное значения в массиве
    min_val = min(arr)
    max_val = max(arr)
    
    # Рассчитываем количество баков (количество интервалов значений)
    num_buckets = len(arr)
    buckets = [[] for _ in range(num_buckets)]

    # Расчёт размера каждого интервала ("ширины") бака
    interval_size = (max_val - min_val + 1) / float(num_buckets)

    # Распределение элементов по соответствующим бакам
    for value in arr:
        index = int((value - min_val) // interval_size)
        
        # Чтобы избежать выхода индекса за пределы списка,
        # ограничиваем индекс последним возможным значением
        if index >= num_buckets:
            index = num_buckets - 1
            
        # Добавляем элемент в соответствующий бак
        buckets[index].append(value)

    # Сортируем элементы внутри каждого бака индивидуально
    sorted_arr = []
    for bucket in buckets:
        # Используем встроенную быструю сортировку quicksort для каждого бака
        sorted_bucket = sorted(bucket)
        sorted_arr.extend(sorted_bucket)

    return sorted_arr


# Пример использования
arr = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
sorted_array = bucket_sort(arr)
print("Отсортированный массив:", sorted_array)

#Отсортированный массив: [0.1234, 0.3434, 0.565, 0.656, 0.665, 0.897]



#Блинная сортировка 
def flip(arr, i):
    """Перевернуть верхнюю часть массива начиная с начала до индекса i включительно."""
    start = 0
    while start < i:
        # Меняем местами первый и последний элементы, постепенно уменьшая длину оставшейся части
        arr[start], arr[i] = arr[i], arr[start]
        start += 1
        i -= 1

def find_max(arr, n):
    """Нахождение индекса наибольшего элемента в неотсортированном диапазоне."""
    mi = 0  # Начальное предположение, что максимум находится в самом начале
    for i in range(1, n):  # Проходим по всему массиву до конца текущего подсчета
        if arr[i] > arr[mi]:  # Обновляем позицию максимума, если нашли больший элемент
            mi = i
    return mi

def pancake_sort(arr):
    """Основная функция блинной сортировки."""
    curr_size = len(arr)  # Текущий размер несортированного участка массива
    while curr_size > 1:  # Пока не останется единственный элемент
        # Найти индекс самого большого элемента в текущем диапазоне
        mi = find_max(arr, curr_size)
        
        # Перевернуть верхний участок массива так, чтобы максимум оказался первым элементом
        if mi != curr_size - 1:  # Только если максимум ещё не на месте
            flip(arr, mi)  # Переворот верхней части массива до найденного максимума
            flip(arr, curr_size - 1)  # Теперь переворачиваем всё, чтобы максимум ушёл вниз
        
        # Уменьшаем область рассмотрения, исключив последнюю позицию (уже отсортированную)
        curr_size -= 1
    return arr

# Пример использования
arr = [3, 6, 2, 4, 5, 1]
sorted_arr = pancake_sort(arr)
print("Отсортированный массив:", sorted_arr)
#Отсортированный массив: [1, 2, 3, 4, 5, 6]



#Сортировка бусинами (гравитационная)
import numpy as np

def bead_sort(arr):
    """
    Алгоритм сортировки бусинками (гравитационной сортировкой).
    Возвращает отсортированный массив целых положительных чисел.
    """
    # Преобразование входного массива в NumPy-массив
    array = np.array(arr)
    
    # Максимальное значение определяет высоту сетки
    height = array.max()
    
    # Создаем матрицу из нулей размером N x M (N - высота, M - ширина)
    grid = np.zeros((height, len(array)), dtype=int)
    
    # Заполняем ячейки матриц буслинками (единицами),
    # соответствующее значениям исходного массива
    for col_idx, val in enumerate(array):
        grid[:val, col_idx] = 1
    
    # Гравитация действует вертикально вниз: суммируем по строкам
    beads_per_row = grid.sum(axis=1)
    
    # Переносим бусинки вниз, формируя новую структуру
    result_grid = np.zeros_like(grid)
    idxs = list(range(len(beads_per_row)))
    idxs.sort(key=lambda x: beads_per_row[x])
    
    # Формируем отсортированный массив, заполнив каждую строку по порядку
    for row_idx, count in zip(idxs, beads_per_row):
        result_grid[row_idx, :count] = 1
    
    # Извлекаем результат путем суммирования столбцов
    sorted_arr = result_grid.sum(axis=0)[::-1]
    
    return sorted_arr.tolist()

# Пример использования
input_list = [5, 3, 1, 4, 2]
output_list = bead_sort(input_list)
print(f'Исходный массив: {input_list}')
print(f'Отсортированный массив: {output_list}')
#Исходный массив: [5, 3, 1, 4, 2]
#Отсортированный массив: [1, 2, 3, 4, 5]



#Поиск скачками (Jump Search)
import math

def jump_search(arr, target):
    """
    Выполняет поиск скачком в отсортированном массиве.
    Возвращает индекс элемента, если он найден, иначе возвращает None.
    """
    length = len(arr)
    step = int(math.sqrt(length))  # Величина прыжка

    prev = 0  # Начинаем с начала массива
    next_step = step  # Первая позиция следующего прыжка

    # Ищем блок, содержащий целевой элемент
    while next_step < length and arr[next_step] <= target:
        prev = next_step
        next_step += step

    # Двигаемся назад от последнего прыжка и ищем элемент
    for i in range(prev, min(next_step, length)):
        if arr[i] == target:
            return i

    return None  # Элемент не найден

# Пример использования
arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
target_value = 55
index = jump_search(arr, target_value)

if index is not None:
    print(f'Элемент {target_value} найден на индексе {index}.')
else:
    print('Элемент не найден.')
#Элемент 55 найден на индексе 10.



#Экспоненциальный поиск (Exponential Search)
def binary_search(arr, left, right, target):
    """
    Классический бинарный поиск внутри определенного диапазона.
    """
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # Элемент не найден

def exponential_search(arr, target):
    """
    Экспоненциальный поиск в отсортированном массиве.
    """
    if not arr or arr[0] > target or arr[-1] < target:
        return -1  # Выход за границы или пустой массив

    bound = 1  # Начинаем с шага 1
    while bound < len(arr) and arr[bound] < target:
        bound *= 2  # Удвоение шага

    # Применяем бинарный поиск в нужном диапазоне
    left = bound // 2
    right = min(bound, len(arr)-1)
    return binary_search(arr, left, right, target)

# Пример использования
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
target_value = 11
index = exponential_search(arr, target_value)

if index != -1:
    print(f'Элемент {target_value} найден на индексе {index}.')
else:
    print('Элемент не найден.')
#Элемент 11 найден на индексе 5.



#Тернарный поиск (Ternary Search)
def ternary_search(arr, target):
    """
    Алгоритм тернарного поиска для поиска элемента в отсортированном массиве.
    """
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        # Определяем две трети и треть от диапазона
        third1 = low + (high - low) // 3
        third2 = high - (high - low) // 3
        
        # Если середина первая совпадает с целью, возвращаем её индекс
        if arr[third1] == target:
            return third1
        
        # Если вторая середина совпадает с целью, возвращаем её индекс
        if arr[third2] == target:
            return third2
        
        # Узкий выбор следующего диапазона
        if target < arr[third1]:
            high = third1 - 1
        elif target > arr[third2]:
            low = third2 + 1
        else:
            low = third1 + 1
            high = third2 - 1
    
    return -1  # Целевого элемента нет в массиве

# Пример использования
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
target_value = 11
index = ternary_search(arr, target_value)

if index != -1:
    print(f'Элемент {target_value} найден на индексе {index}.')
else:
    print('Элемент не найден.')
#Элемент 11 найден на индексе 5.
