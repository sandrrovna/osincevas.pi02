1.	Вариант 19. Жадный алгоритм для минимального остовного дерева (Алгоритм Крускала) Задача: реализовать алгоритм Крускала
с жадной стратегией для нахождения минимального остовного дерева. Требования: - Использовать структуру Union-Find для проверки
циклов - Входные данные: граф с весами ребер - Выход: список ребер остовного дерева и общий вес Входные данные: Граф с 6 вершинами
и 9 ребрами с весами
2.	Описание алгоритма:
Алгоритм Крускала строит минимальное остовное дерево (MST) жадным способом, последовательно добавляя рёбра с наименьшим весом,
избегая образования циклов.
	1)	Сначала сортируем рёбра графа по возрастанию их весов.
sorted_graph = sorted(graph, key=lambda edge: edge[0])
	2)	Затем последовательно добавляем каждое ребро в итоговое дерево, проверяя при помощи структуры Union-Find, не образуется ли цикл.
if uf.find(u) != uf.find(v):  
		uf.union(u, v)           
	3)	Если добавление нового ребра создаёт цикл, пропускаем его. Иначе включаем в решение. 
mst_edges.append((weight, u, v))  
   total_weight += weight
3.	Временная сложность: O(ElogE), где E – число рёбер.
4.	Почему: Каждый вызов операций find и union внутри цикла занимает амортизированное время благодаря оптимизации сжатия путей и
ранга. 
5.	Контрольный вопрос: Какой компромисс существует между точностью приближенного алгоритма и скоростью его работы?
Компромисс между точностью приближенного алгоритма и скоростью его работы заключается в том, что увеличение точности обычно
требует больше вычислительных ресурсов и времени. В то время как более быстрые алгоритмы могут давать менее точные результаты,
что делает их подходящими для задач, где время критично, но небольшие погрешности допустимы.
