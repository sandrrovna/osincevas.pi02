Алгоритмы сортировки
Блочная (корзинная) сортировка
1. Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.
4. Принцип работы:
1) Определяется количество корзин (например, по диапазону значений элементов).
num_buckets = len(arr)
buckets = [[] for _ in range(num_buckets)]
2) Каждый элемент помещается в корзину согласно функции распределения.
for value in arr:
        index = int((value - min_val) // interval_size)
        if index >= num_buckets:
            index = num_buckets - 1
        buckets[index].append(value)
3) Содержимое каждой корзины сортируется индивидуально.
sorted_arr = []
    for bucket in buckets:
        sorted_bucket = sorted(bucket)
        sorted_arr.extend(sorted_bucket)
4) Корзины соединяются в порядке увеличения диапазона.
return sorted_arr
5. Оценка временной сложности алгоритма: O(n)
6. Объяснение оценки временной сложности алгоритма: Временная сложность O(n) возникла в связи с тем, что каждый элемент проходит проверку и помещается в соответствующий бак; цикл повторяется ровно столько же раз, сколько элементов в массиве. 

Блинная сортировка
1. Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.
4. Принцип работы:
1) Найти максимальный элемент в неотсортированной части массива.
def find_max(arr, n):    
	mi = 0    for i in range(1, n):        
		if arr[i] > arr[mi]:           
			 mi = i    
return mi
2) Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым.
if mi != curr_size - 1:            
	flip(arr, mi)            
3) Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
flip(arr, curr_size - 1)
4) Повторить процесс для оставшейся неотсортированной части массива.
curr_size -= 1
5. Оценка временной сложности алгоритма: O(n^2).
6. Объяснение оценки временной сложности алгоритма: Временная сложность O(n^2) возникла в связи с тем, что поиск максимального элемента требует проход по всей рассматриваемой области; алгоритм выполняет такое действие для каждого из n элементов.

Сортировка бусинами (гравитационная)
1. Определение: Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. 
4. Принцип работы:
1) Каждый элемент массива представляется в виде горизонтального ряда бусин,
количество которых соответствует его значению.
array = np.array(arr)
2) Бусины располагаются на «стержнях» (как на абаке).
height = array.max()
3) Под действием «гравитации» бусины падают вниз.
beads_per_row = grid.sum(axis=1)
4) После оседания бусин строки считываются сверху вниз — получается
отсортированный массив.
for row_idx, count in zip(idxs, beads_per_row):
        result_grid[row_idx, :count] = 1
5. Оценка временной сложности алгоритма: O(n^2).
6. Объяснение оценки временной сложности алгоритма: Временная сложность O(n^2) возникла в связи с необходимостью обработки каждой пары строк-столбцов дважды: при формировании начальной сетки и при обработке гравитации.

Алгоритмы поиска
Поиск скачками (Jump Search)
1. Определение: Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.
4. Принцип работы:
1) Делится массив на блоки длины m=n.
length = len(arr)
step = int(math.sqrt(length))
2) Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный искомому.
while next_step < length and arr[next_step] <= target:    
	prev = next_step    
	next_step += step
3) Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке.
for i in range(prev, min(next_step, length)):    
	if arr[i] == target:        
		return i

5. Оценка временной сложности алгоритма: O(n).
6. Объяснение оценки временной сложности алгоритма: Временная сложность O(n) возникла в связи с тем, что данные отсортированы и доступ к элементам осуществляется за постоянное время.


Экспоненциальный поиск (Exponential Search)
1. Определение: Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.
4. Принцип работы:
1) Проверяется первый элемент массива.
def binary_search(arr, left, right, target):
2) Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д., пока не будет найден элемент, больше или равный искомому.
if not arr or arr[0] > target or arr[-1] < target:    return -1
3) На найденном диапазоне выполняется бинарный поиск.
return binary_search(arr, left, right, target)
5. Оценка временной сложности алгоритма: O(log n).
6. Объяснение оценки временной сложности алгоритма: Временная сложность O(log n) возникла в связи с тем, что на этапе увеличения дистанции (экпоненциальный рост) требуется O(log n)  шагов; следующая стадия — бинарный поиск, который также выполняется за O(log n).

Тернарный поиск (Ternary Search)
1. Определение: Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или экстремум функции (в зависимости от задачи).
4. Принцип работы (для массива):
1) Делится диапазон индексов на три части.
third1 = low + (high - low) // 3
third2 = high - (high - low) // 3
2) Сравнивается искомый элемент с элементами на двух разделительных границах.
if arr[third1] == target:    
	return third1
if arr[third2] == target:    
	return third2
3) Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети
массива, где может находиться искомое значение.
return -1
5. Оценка временной сложности алгоритма: O(log3n).
6. Объяснение оценки временной сложности алгоритма: Временная сложность O(log3n) возникла в связи с тем, что тернарный поиск сокращает диапазон поиска на каждом шаге, но делает это не наполовину, а на треть.
Число необходимых шагов пропорционально логарифму от размера массива, но основанием служит 3 (так как деление идет на три части).
