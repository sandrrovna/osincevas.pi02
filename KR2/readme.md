1. Вариант: 20. Имитация отжига для задачи размещения центров
Условие. Разместить k центров на плоскости так, чтобы минимизировать суммарное
расстояние от каждой из n точек‑клиентов до ближайшего центра.
Алгоритм: имитация отжига: случайное смещение центров, принятие решения по критерию
Метрополиса.
Язык примера: C++
vector<pair<double, double>> sa_facility_location(
 const vector<pair<double, double>>& clients,
 int k, double temp, double cooling
) {
 // Инициализация: случайные позиции k центров
 vector<pair<double, double>> centers(k);
 for (int i = 0; i < k; i++) {
 centers[i] = {
 random_double(-10, 10),
 random_double(-10, 10)
 };
 }
 double current_cost = totalDistance(clients, centers);
 while (temp > 1e-6) {
 // Создаём кандидата: сдвигаем один случайный центр
 vector<pair<double, double>> new_centers = centers;
 int idx = random_int(0, k - 1);
 new_centers[idx].first += random_double(-1, 1) * temp;
 new_centers[idx].second += random_double(-1, 1) * temp;
 double new_cost = totalDistance(clients, new_centers);
 // ДОПИСАТЬ: принять/отклонить new_centers по критерию Метрополиса
 // Если принято, обновить centers и current_cost
 temp *= cooling;
 }
 return centers;
}
Что дописать:
	1. Условие принятия нового решения:
	o если new_cost < current_cost, принимаем;
	o иначе принимаем с вероятностью exp((current_cost - new_cost)/temp).
	2. Обновление centers и current_cost при принятии.
Примечания:
	• Функция totalDistance считает сумму расстояний от каждого клиента до
	ближайшего центра.
	• random_double(a, b) возвращает случайное число из [a,b].
	• random_int(a, b) возвращает случайное целое из [a,b].

2. Описание алгоритма: 
	Шаг 1. Инициализация начальных центров:
	Центры инициализируются случайными позициями внутри прямоугольника 	размером [-10, 10] x [-10, 10].
vector<Point> centers(k);
    for (int i = 0; i < k; ++i) {
        centers[i] = {random_double(-10, 10), random_double(-10, 10)};

	Шаг 2. Основной цикл метода имитации отжига:
	Повторяется пока температура больше некоторого минимального 		значения (1e-6). Температура
  постепенно уменьшается по экспоненте 		(cooling_rate), имитируя процесс остывания материала.
 while (temperature > 1e-6) {

	Шаг 3. Создание кандидата:
	Из существующих центров выбирается случайный центр и слегка смещается 	вдоль каждой оси на величину,
  зависящую от текущей температуры.
vector<Point> new_centers = centers;

	Шаг 4. Оценка стоимости кандидатского решения:
	Для кандидатов вычисляется общая сумма расстояний от каждого клиента 	до ближайшего центра.
double new_cost = totalDistance(clients, new_centers);

	Шаг 5. Принятие кандидата:
	Критерий Метрополиса: новый кандидат принимается, если:
	Новая конфигурация лучше предыдущей;
	Или вероятность экспоненциально зависит от разницы стоимостей и 			текущей температуры.
if (new_cost < current_cost || exp((current_cost - new_cost) / temperature) >= random_double(0, 1)) {

	Шаг 6. Обновление решений:
	Если кандидат принят, обновляем центры и значение общей стоимости.
centers = new_centers;
            current_cost = new_cost;
        }

3. Временная сложность:  O(T*N*K), где:
	T — количество итераций цикла отжига (температурных шагов),
	N — количество клиентов,
	K — количество центров.

4. Почему: Такая временная сложность связана с тем, что основная операция — это расчёт суммы расстояний,
выполняемый на каждом шаге.

5. Контрольный вопрос 20: Применение в практике
Приведите 5 примеров реальных приложений, где используются приближенные или
эвристические алгоритмы

Эвристические и приближенные алгоритмы широко применяются там, где точное решение невозможно найти быстро 
из-за больших объемов данных или сложности задачи.
	1. Планирование маршрутов транспорта (проблема коммивояжера)
	Пример: логистические компании используют эвристики для построения 	эффективных маршрутов доставки 
  товаров. Точные методы трудно 	масштабировать на большие объемы городов и заказов, поэтому 	
  применяют приближенные алгоритмы вроде жадных методов, 	генетического алгоритма или локальных поисков.
	2. Распределение ресурсов и расписания (расписание экзаменов, 	расписание персонала)
	Пример: университеты и крупные организации сталкиваются с задачей 	составления расписаний занятий 
  или рабочей смены сотрудников. 	Использование точного подхода здесь сложно из-за большого числа 	
  ограничений и комбинаторной природы задачи. Эвристики позволяют 	получать приемлемые результаты 
  гораздо быстрее.
	3. Оптимизация размещения складов и производственных мощностей
	Пример: предприятия стремятся минимизировать транспортные расходы, 	обеспечивая доступность продукции 
  клиентам. Приближенные алгоритмы 	помогают выбирать места для складов и заводов, учитывая 	
  географическое распределение спроса и поставщиков.
	4. Управление сетью телекоммуникаций и распределением каналов связи
	Пример: мобильные операторы распределяют частоты и каналы связи 	между абонентами в сетях сотовых 
  телефонов. Задача распределения 	частот является NP-трудной, поэтому точные подходы неприменимы. 	
  Используются эвристики и метаэвристики, такие как муравьиные 		алгоритмы и эволюционные стратегии.
	5. Машинное обучение и обработка изображений
	Пример: задачи классификации изображений, распознавания речи или 	рекомендации продуктов требуют 
  обработки огромных массивов данных. 	Приближенные алгоритмы, такие как случайные леса, градиентный 
  бустинг 	и нейронные сети, позволяют справляться с такими объемами, предлагая 	быстрые и эффективные 
  решения.
