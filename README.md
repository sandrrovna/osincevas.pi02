Алгоритмы сортировки

Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный 
элемент среди последних и меняют его местами с текущим элементом в массиве. 
Объяснение работы алгоритма: Основной цикл for определяет позицию следующего элемента, 
который нужно вставить в отсортированную область. Внутри внешнего цикла используется внутренний 
цикл, проходящий по оставшимся элементами массива (начиная с текущего положения внешнего цикла). 
Задача этого цикла — найти минимальный элемент в неотсортированной части массива.
Когда минимальный элемент найден, он меняется местами с текущим элементом (тем, на котором 
остановился внешний цикл). Таким образом, минимальная величина становится частью отсортированной 
зоны. Процесс повторяется, пока весь массив не окажется отсортированным.
Временная сложность: O(n²)
Почему: Два вложенных цикла.
Внешний цикл проходит по всем элементам (проходит n-1 раз),
Внутренний цикл также рассматривает почти все элементы (для последнего прохода достаточно лишь 
одно сравнение).

Сортировка обменом (пузырьком) (Bubble Sort) - алгоритм проходит по списку несколько 
раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном 
порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
Объяснение работы алгоритма: Просмотр массива слева направо. Когда соседние элементы идут 
в неправильной последовательности (левый элемент больше правого), меняем их местами. К концу 
первого прохода наибольший элемент гарантированно переместился в конец массива. Затем повторяем 
тот же процесс, но теперь мы знаем, что последний элемент уже стоит на своём месте, поэтому 
уменьшаем область просмотра массива на единицу (не смотрим последний элемент). Подобным образом 
продолжаем проходить по массиву, каждый раз сдвигаясь ближе к началу, пока не убедимся, что 
массив полностью отсортирован.
Временная сложность: O(n²)
Почему: Если массив отсортирован в обратном порядке, алгоритм производит максимальное количество 
сравнений и обменов. Каждое прохождение по массиву даёт нам примерно половину общего количества 
элементов, что ведет к квадратичной зависимости.

Сортировка вставками (Insertion Sort) - алгоритм строит отсортированную часть списка, 
постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и 
перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его 
на правильное место. 
Объяснение работы алгоритма: На старте первый элемент массива считаем уже отсортированным. 
Остальные элементы будем рассматривать по очереди. Берем очередной элемент массива и временно 
сохраняем его отдельно. Освобождаем место для вставки текущего элемента, сдвигая уже 
отсортированные элементы вправо. Вставляем текущий элемент в освободившееся место. Повторяем 
этот процесс для каждого следующего элемента, расширяя отсортированную часть массива.
Временная сложность: O(n²)
Почему: Обычно приходится многократно просматривать отсортированную часть массива, сдвигая 
элементы.

Сортировка слиянием (Merge Sort) - алгоритм состоит в разделении массива пополам, 
сортировке половин и их слиянии.
Объяснение работы алгоритма: Массив делится на две равные части до тех пор, пока каждая из частей 
не станет содержать ровно один элемент. Одинарный элемент по определению уже отсортирован. Уже 
отсортированные фрагменты объединяются в единое целое, сохраняя правильный порядок элементов. 
Процедура слияния проходит снизу вверх, постепенно формируя полную отсортированную версию массива.
Временная сложность: O(n log n)
Почему: Разделяя массив на две равные части, мы тратим примерно O(logn) уровней рекурсии. Для 
каждой отдельной операции слияния требуется пройти по обоим подмассивам одновременно, что даёт 
линейную временную сложность O(n). 

Сортировка Шелла (Shellsort) - является модификацией сортировки вставками, сортирует 
между собой элементы, стоящие на местах, кратных определённому шагу.
Объяснение работы алгоритма: Первоначально задаётся большой промежуток (шаг) между элементами, 
которые будут сравниваться. Затем элементы на расстоянии этого шага сортируются с помощью 
обычного алгоритма вставок. Расстояние постепенно уменьшается, пока не сократится до единицы, 
после чего происходит обычная сортировка вставками.
Временная сложность: O(n log n)
Почему: Массив уже отсортирован, но даже тогда алгоритм придется провести несколько итераций.

Быстрая сортировка (Quick Sort) - один из самых известных и широко используемых 
алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива 
на две части относительно опорного (одна — все элементы, меньшие опорного элемента, 
вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них. 
Объяснение работы алгоритма: Выбирается центральный элемент массива. Обе части (левая и правая) 
сортируются аналогичным способом, и этот процесс продолжается до тех пор, пока каждая группа не 
станет достаточно маленькой (одноэлементной или пустым массивом). Результаты собираются вместе, 
образуя отсортированный массив.
Временная сложность: O(n²)
Почему: Опорный элемент регулярно оказывается экстремально плохим (например, всегда выбирается 
наименьший или наибольший элемент).

Пирамидальная сортировка - алгоритм строит кучу из исходного списка, затем постепенно 
извлекает наибольший элемент из кучи и помещает его в конец списка.
Объяснение работы алгоритма: Исходный массив преобразуется в двоичную кучу, где каждый 
родительский элемент больше своих потомков. Наибольший элемент (верхушка кучи) последовательно 
перемещается в конец массива, а куча перестраивается, исключая этот элемент. Такой процесс 
повторяется до тех пор, пока все элементы не окажутся отсортированными.
Временная сложность: O(n log n)
Почему: Построение первоначальной кучи занимает O(n) времени, так как операцию heapify надо 
применить ко всем внутренним узлам. Извлечение каждого элемента и восстановление кучи занимают 
O(log n) на каждом шаге, и таких шагов будет n. Следовательно, общая сложность этапа 
сортировки — O(n log n).


Алгоритмы поиска

Последовательный (линейный) поиск - простейший вид поиска заданного элемента на 
некотором множестве. Осуществляется путём последовательного сравнения очередного 
рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. 
Объяснение работы алгоритма: Функция sequential_search получает два параметра: arr: список, в 
котором производится поиск; target: искомое значение. Алгоритм проходит по каждому элементу 
списка с помощью конструкции for index, value in enumerate(arr). Это удобно, так как мы 
одновременно получаем и индекс элемента, и само значение. Для каждого элемента списка проверяется 
условие: Если текущий элемент (value) совпадает с искомым (target), немедленно возвращается 
индекс этого элемента. Если после полного прохода по списку искомое значение не найдено, 

возвращается специальное значение (-1), означающее, что элемент отсутствует в списке.
Временная сложность:  O(n)
Почему: Алгоритм последовательно проверяет каждый элемент списка. В худшем случае (если элемент 
находится в конце списка или вообще отсутствует), нам придётся просмотреть весь список целиком.

Бинарный (двоичный, дихотомический) поиск - это поиск заданного элемента на 
упорядоченном множестве, осуществляемый путём неоднократного деления этого множества 
на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск 
заканчивается при совпадении искомого элемента с элементом, который является границей 
между частями множества или при отсутствии искомого элемента.
Объяснение работы алгоритма: В первую очередь мы определяем середину массива и проверяем, 
совпадает ли значение в середине с искомым элементом. Если середина оказалась больше искомого 
значения, мы отбрасываем вторую половину массива и продолжаем поиск в первой половине. Если 
середина меньше, наоборот, игнорируем первую половину и исследуем вторую. Каждый раз область 
поиска сокращается вдвое, пока не будет достигнут один из двух возможных вариантов: Элемент 
найден; Поиск завершился без результата (область поиска опустела).
Временная сложность: O(log n)
Почему: Алгоритм последовательно сокращает область поиска в два раза на каждом шаге.

Интерполирующий поиск - это алгоритм поиска для отсортированных наборов данных, 
таких как массивы или списки. Он предсказывает позицию нужного элемента на основе 
разницы значений. Эффективен, если элементы распределены достаточно равномерно. 
Объяснение работы алгоритма: Алгоритм вычисляет предполагаемую позицию искомого элемента, 
используя формулу интерполяции, основанную на соотношении между нижней границей, верхней 
границей и целевым значением. Затем проверяется, действительно ли элемент, находящийся на 
рассчитанном индексе, соответствует искомому. Если нет, корректируется диапазон поиска, и 
процесс повторяется. Поиск заканчивается, когда элемент найден или диапазон сузился настолько, 
что дальнейшее продолжение невозможно.
Временная сложность: O(n)
Почему: значения распределены неравномерно

Поиск по Фибоначчи - это эффективный алгоритм поиска, используемый для нахождения 
целевого значения в отсортированной коллекции, такой как массив или список. По принципу 
он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций 
для сравнения.
Объяснение работы алгоритма: Сначала мы генерируем числа Фибоначчи до тех пор, пока последнее 
число не станет больше или равно длине массива. Эти числа определяют, каким образом мы будем 
делить массив на части. Далее мы используем полученные числа Фибоначчи для расчета точки 
проверки в массиве. Основываясь на размере массива и соотношении чисел Фибоначчи, мы определяем, 
какую часть массива пропустить, а какую продолжить исследовать. После нахождения подходящей точки, 
мы проверяем, находится ли искомый элемент в этой позиции. Если элемент найден, алгоритм 
завершается. Если нет, массив делится на две части, и процесс повторяется для соответствующей 
половины. Поиск заканчивается, когда нужная позиция найдена или установлено, что элемент 
отсутствует в массиве.
Временная сложность: O(log n)
Почему: Эта сложность связана с особенностями деления массива на неравные части с помощью 
чисел Фибоначчи.
