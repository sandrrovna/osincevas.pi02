def bubble_sort(arr):
    """
    Реализация алгоритма сортировки пузырьком.
    :param arr: Список целых чисел, подлежащих сортировке.
    """
    n = len(arr)                       # Определяем длину списка
    for i in range(n):                 # Повторяем n раз (количество проходов)
        swapped = False                 # Флаг, показывающий были ли выполнены перестановки
        for j in range(0, n-i-1):      # Проходим по списку от начала до конца минус i-й элемент
            if arr[j] > arr[j+1]:      # Если текущий элемент больше последующего
                arr[j], arr[j+1] = arr[j+1], arr[j]  # Меняем их местами
                swapped = True          # Ставим флаг, что произошла замена
        if not swapped:                 # Если в данном проходе ничего не изменилось
            break                       # Заканчиваем сортировку досрочно

if name == "main":
    array = [64, 34, 25, 12, 22, 11]  # Исходный список
    print("Исходный массив:", array)   # Выводим исходный массив
    bubble_sort(array)                 # Запускаем сортировку
    print("Отсортированный массив:", array)  # Выводим отсортированный массив
#Исходный массив: [64, 34, 25, 12, 22, 11]
#Отсортрованный массив: [11, 12, 22, 25, 34, 64]

def insertion_sort(arr):
    """
    Реализация алгоритма сортировки вставками.
    :param arr: Входной массив для сортировки.
    """
    # Проходим по массиву начиная со второго элемента (индекс 1)
    for i in range(1, len(arr)):
        # Берём текущий элемент
        current_value = arr[i]
        position = i
        
        # Смещаемся назад по уже отсортированной части массива,
        # пока не найдём подходящее место для вставки текущего элемента
        while position > 0 and arr[position - 1] > current_value:
            # Если предыдущий элемент больше текущего, сдвигаем его вправо
            arr[position] = arr[position - 1]
            position -= 1
        
        # Вставляем текущий элемент на правильную позицию
        arr[position] = current_value


# Тестируем алгоритм
if name == "main":
    # Пример массива для сортировки
    example_array = [64, 34, 25, 12, 22, 11]
    
    # Выводим исходный массив
    print("Исходный массив:", example_array)
    
    # Вызываем функцию сортировки
    insertion_sort(example_array)
    
    # Выводим отсортированный массив
    print("Отсортированный массив:", example_array)

#Исходный массив: [64, 34, 25, 22, 11]
#Отсортированный массив: [11, 12, 22, 25, 34, 64]

def shell_sort(arr):
    """
    Реализация алгоритма сортировки Шелла.
    :param arr: Список целых чисел, подлежащий сортировке.
    """
    gap = len(arr) // 2  # Первоначальный интервал (шаг)
    
    # Продолжаем уменьшать интервал, пока он не станет нулевым
    while gap > 0:
        # В пределах интервала делаем обычную сортировку вставками
        for i in range(gap, len(arr)):  
            temp = arr[i]               # Сохраняем текущий элемент
            j = i                       # Стартовая позиция для вставки
            
            # Пробегаем по отсортированной части с шагом 'gap'
            while j >= gap and arr[j-gap] > temp:  
                arr[j] = arr[j-gap]    # Сдвигаем элемент вправо
                j -= gap                # Переходим к следующему элементу
                
            arr[j] = temp               # Вставляем текущий элемент на своё место
        
        # Уменьшаем интервал (обычно вдвое)
        gap //= 2

# Пример использования
if name == "main":
    data = [64, 34, 25, 12, 22, 11, 90]
    print("Исходный массив:", data)
    shell_sort(data)
    print("Отсортированный массив:", data)
    
#Исходный массив: [64, 34, 25, 12, 22, 11, 90]
#Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

def quick_sort(arr):
    """
    Реализация алгоритма быстрой сортировки.
    :param arr: Входной список, подлежащий сортировке.
    """
    if len(arr) <= 1:                             # База рекурсии: пустой или односимвольный список уже отсортирован
        return arr                                # Возвращаем исходный список
    
    pivot = arr[len(arr) // 2]                    # Выбор опорного элемента (средний элемент массива)
    left = [x for x in arr if x < pivot]          # Все элементы меньше опорного
    middle = [x for x in arr if x == pivot]       # Элементы, равные опорному
    right = [x for x in arr if x > pivot]         # Все элементы больше опорного
    
    # Рекурсивно сортируем левую и правую части и собираем результат
    return quick_sort(left) + middle + quick_sort(right)

# Пример использования
if name == "main":
    data = [64, 34, 25, 12, 22, 11, 90]
    sorted_data = quick_sort(data)
    print("Отсортированный массив:", sorted_data)
    
#Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

def sequential_search(arr, target):
    """
    Реализация алгоритма последовательного поиска.
    :param arr: Список элементов, в котором производится поиск.
    :param target: Значение, которое мы ищем.
    :return: Индекс искомого элемента, если он найден; иначе -1.
    """
    # Проходим по каждому элементу массива
    for index, value in enumerate(arr):
        # Если нашли нужный элемент, возвращаем его индекс
        if value == target:
            return index
    # Если элемент не найден, возвращаем -1
    return -1

# Пример использования
if name == "main":
    my_list = [64, 34, 25, 12, 22, 11, 90]
    search_element = 25
    result = sequential_search(my_list, search_element)

    if result != -1:
        print(f"Элемент {search_element} найден на позиции {result}.")
    else:
        print(f"Элемент {search_element} не найден.")
        
#Элемент 25 найден на позиции 2.
